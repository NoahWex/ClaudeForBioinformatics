#!/usr/bin/env python3
"""
Knowledge base management - Index, search, and manage knowledge entries.

Entry types:
- lesson: Hard-won debugging knowledge
- research: Literature summaries, method comparisons
- pattern: Validated reusable code patterns
"""

import os
import re
import yaml
from pathlib import Path
from dataclasses import dataclass, field
from typing import Optional
from datetime import date


# Because apparently remembering things is too hard without a YAML file.


@dataclass
class KnowledgeEntry:
    """A knowledge base entry with metadata."""
    id: str
    path: Path
    type: str  # lesson | research | pattern
    created: str
    updated: str
    source: str  # debugging | literature | deep_research | experiment
    tags: list[str] = field(default_factory=list)
    severity: Optional[str] = None  # high | medium | low (for lessons)
    zotero_key: Optional[str] = None
    title: str = ""
    content: str = ""

    def to_index_dict(self) -> dict:
        """Convert to index entry format."""
        d = {
            "path": str(self.path),
            "type": self.type,
            "created": self.created,
            "updated": self.updated,
            "source": self.source,
            "tags": self.tags,
            "title": self.title
        }
        if self.severity:
            d["severity"] = self.severity
        if self.zotero_key:
            d["zotero_key"] = self.zotero_key
        return d


def parse_entry(content: str, path: Path) -> Optional[KnowledgeEntry]:
    """Parse a knowledge entry from file content."""
    # Extract frontmatter
    frontmatter_match = re.match(r'^---\n(.*?)\n---\n', content, re.DOTALL)
    if not frontmatter_match:
        return None

    try:
        data = yaml.safe_load(frontmatter_match.group(1)) or {}
    except yaml.YAMLError:
        return None

    # Extract title (first # heading)
    body = content[frontmatter_match.end():]
    title_match = re.match(r'^#\s+(.+)$', body.strip(), re.MULTILINE)
    title = title_match.group(1) if title_match else ""

    # Handle date objects
    created = data.get('created', str(date.today()))
    if hasattr(created, 'isoformat'):
        created = created.isoformat()
    updated = data.get('updated', created)
    if hasattr(updated, 'isoformat'):
        updated = updated.isoformat()

    return KnowledgeEntry(
        id=data.get('id', path.stem),
        path=path,
        type=data.get('type', 'lesson'),
        created=str(created),
        updated=str(updated),
        source=data.get('source', 'unknown'),
        tags=data.get('tags', []),
        severity=data.get('severity'),
        zotero_key=data.get('zotero_key'),
        title=title,
        content=body
    )


def parse_entry_file(path: Path) -> Optional[KnowledgeEntry]:
    """Parse a knowledge entry from a file path."""
    content = path.read_text()
    return parse_entry(content, path)


class KnowledgeIndex:
    """Knowledge base index manager."""

    def __init__(self, knowledge_dir: Path):
        self.knowledge_dir = knowledge_dir
        self.index_path = knowledge_dir / ".index.yaml"
        self.entries: dict[str, KnowledgeEntry] = {}

    def load_index(self) -> dict:
        """Load index from disk."""
        if self.index_path.exists():
            with open(self.index_path) as f:
                data = yaml.safe_load(f) or {}
                return data.get('entries', {})
        return {}

    def save_index(self):
        """Save index to disk."""
        index_data = {
            "entries": {
                entry_id: entry.to_index_dict()
                for entry_id, entry in self.entries.items()
            }
        }
        with open(self.index_path, 'w') as f:
            f.write("# Knowledge Base Index\n")
            f.write("# Auto-generated by ./plan knowledge add\n")
            f.write("# Manual edits will be overwritten\n\n")
            yaml.dump(index_data, f, default_flow_style=False, sort_keys=False)

    def scan_entries(self):
        """Scan all .md files in knowledge directory."""
        self.entries = {}

        for md_file in self.knowledge_dir.rglob("*.md"):
            # Skip README and hidden files
            if md_file.name == "README.md" or md_file.name.startswith("."):
                continue

            entry = parse_entry_file(md_file)
            if entry:
                # Use relative path from knowledge_dir
                rel_path = md_file.relative_to(self.knowledge_dir)
                entry.path = rel_path
                self.entries[entry.id] = entry

    def rebuild_index(self):
        """Scan all entries and rebuild index."""
        self.scan_entries()
        self.save_index()
        return len(self.entries)

    def add_entry(self, path: Path) -> Optional[KnowledgeEntry]:
        """Add or update a single entry in the index."""
        if not path.exists():
            return None

        entry = parse_entry_file(path)
        if entry:
            # Make path relative if it's absolute
            if path.is_absolute():
                try:
                    rel_path = path.relative_to(self.knowledge_dir)
                    entry.path = rel_path
                except ValueError:
                    entry.path = path

            # Load existing index and add/update
            existing = self.load_index()
            self.entries = {}
            for eid, edata in existing.items():
                # Reconstruct minimal entry for existing items
                self.entries[eid] = KnowledgeEntry(
                    id=eid,
                    path=Path(edata['path']),
                    type=edata['type'],
                    created=edata['created'],
                    updated=edata['updated'],
                    source=edata['source'],
                    tags=edata.get('tags', []),
                    severity=edata.get('severity'),
                    zotero_key=edata.get('zotero_key'),
                    title=edata.get('title', '')
                )

            self.entries[entry.id] = entry
            self.save_index()

        return entry

    def search(self, query: str) -> list[KnowledgeEntry]:
        """Search entries by tag or content."""
        query_lower = query.lower()
        results = []

        for entry in self.entries.values():
            # Check tags
            if any(query_lower in tag.lower() for tag in entry.tags):
                results.append(entry)
                continue

            # Check title
            if query_lower in entry.title.lower():
                results.append(entry)
                continue

            # Check type
            if query_lower == entry.type:
                results.append(entry)
                continue

            # Check ID
            if query_lower in entry.id.lower():
                results.append(entry)

        return results

    def get_by_type(self, entry_type: str) -> list[KnowledgeEntry]:
        """Get all entries of a specific type."""
        return [e for e in self.entries.values() if e.type == entry_type]

    def get_entry(self, entry_id: str) -> Optional[KnowledgeEntry]:
        """Get entry by ID."""
        return self.entries.get(entry_id)

    def list_all(self) -> dict[str, list[KnowledgeEntry]]:
        """List all entries grouped by type."""
        grouped = {'lesson': [], 'research': [], 'pattern': []}
        for entry in self.entries.values():
            if entry.type in grouped:
                grouped[entry.type].append(entry)
            else:
                grouped.setdefault('other', []).append(entry)
        return grouped


def get_knowledge_dir(explicit_path: Optional[Path] = None) -> Path:
    """
    Find the .knowledge directory.

    Resolution order:
    1. Explicit path argument (highest priority)
    2. KNOWLEDGE_DIR environment variable
    3. CWD-based discovery (.knowledge or project/.knowledge)
    4. TOOLS_DIR parent traversal (original fallback)
    """
    # 1. Explicit argument
    if explicit_path:
        if explicit_path.exists():
            return explicit_path
        raise FileNotFoundError(f"Specified knowledge directory not found: {explicit_path}")

    # 2. Environment variable
    env_path = os.environ.get('KNOWLEDGE_DIR')
    if env_path:
        path = Path(env_path)
        if path.exists():
            return path
        raise FileNotFoundError(f"KNOWLEDGE_DIR not found: {env_path}")

    # 3. CWD-based discovery
    cwd = Path.cwd()
    for candidate in [cwd / ".knowledge", cwd / "project" / ".knowledge"]:
        if candidate.exists():
            return candidate

    # 4. TOOLS_DIR-based discovery (original fallback)
    current = Path(__file__).parent.parent.parent  # tools -> .plans -> project
    knowledge_dir = current / ".knowledge"
    if knowledge_dir.exists():
        return knowledge_dir

    # Try parent directories
    for parent in current.parents:
        for subpath in ["project/.knowledge", ".knowledge"]:
            knowledge_dir = parent / subpath
            if knowledge_dir.exists():
                return knowledge_dir

    raise FileNotFoundError(
        "Could not find .knowledge directory.\n"
        "Options:\n"
        "  1. Run from project root containing .knowledge/ or project/.knowledge/\n"
        "  2. Set KNOWLEDGE_DIR environment variable"
    )


if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: knowledge.py [rebuild|list|search <query>|show <id>]")
        sys.exit(1)

    knowledge_dir = get_knowledge_dir()
    index = KnowledgeIndex(knowledge_dir)

    cmd = sys.argv[1]

    if cmd == "rebuild":
        count = index.rebuild_index()
        print(f"Index rebuilt: {count} entries")

    elif cmd == "list":
        index.scan_entries()
        grouped = index.list_all()
        for entry_type, entries in grouped.items():
            if entries:
                print(f"\n{entry_type.upper()}S ({len(entries)}):")
                for entry in sorted(entries, key=lambda e: e.updated, reverse=True):
                    tags = ', '.join(entry.tags[:3])
                    print(f"  {entry.id}: {entry.title[:50]} [{tags}]")

    elif cmd == "search" and len(sys.argv) > 2:
        query = sys.argv[2]
        index.scan_entries()
        results = index.search(query)
        if results:
            print(f"Found {len(results)} entries matching '{query}':")
            for entry in results:
                print(f"  {entry.id}: {entry.title} ({entry.type})")
        else:
            print(f"No entries found matching '{query}'")

    elif cmd == "show" and len(sys.argv) > 2:
        entry_id = sys.argv[2]
        index.scan_entries()
        entry = index.get_entry(entry_id)
        if entry:
            print(f"ID: {entry.id}")
            print(f"Type: {entry.type}")
            print(f"Path: {entry.path}")
            print(f"Tags: {', '.join(entry.tags)}")
            print(f"Created: {entry.created}")
            print(f"Updated: {entry.updated}")
            print(f"\n{entry.content[:500]}...")
        else:
            print(f"Entry not found: {entry_id}")

    else:
        print("Unknown command")
        sys.exit(1)
